= SpringApplication 启动时如何选择 ConfigurableApplicationContext

通常会像下面这样启动 Spring Boot 应用：

.ClientInnerApplication
[source%nowrap,java]
----
@SpringBootApplication
public class ClientInnerApplication {
    public static void main(String[] args) {
        SpringApplication.run(ClientInnerApplication.class, args);
    }
}
----

`SpringApplication.run` 会返回一个 `ConfigurableApplicationContext`，那么 `ConfigurableApplicationContext` 的实例类型是如何确定呢？以下源码展示出 `ConfigurableApplicationContext` 的创建过程：

.SpringApplication.createApplicationContext
[source%nowrap,java]
----
protected ConfigurableApplicationContext createApplicationContext() {
    Class<?> contextClass = this.applicationContextClass;
    if (contextClass == null) {
        try {
            switch (this.webApplicationType) {
            case SERVLET:
                contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);
                break;
            case REACTIVE:
                contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);
                break;
            default:
                contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);
            }
        }
        catch (ClassNotFoundException ex) {
            throw new IllegalStateException(
                    "Unable create a default ApplicationContext, please specify an ApplicationContextClass", ex);
        }
    }
    return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);
}
----

可以看到是通过 `webApplicationType` 判断的，不同的 `webApplicationType` 类型选择不同的 `ConfigurableApplicationContext` 子类。那么 `webApplicationType` 的值是怎么确定的呢？以下源码展示出 `webApplicationType` 是在 SpringApplication 实例化时，获取了 `WebApplicationType.deduceFromClasspath()` 的返回值：

.SpringApplication
[source%nowrap,java]
----
public SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {
    this.resourceLoader = resourceLoader;
    Assert.notNull(primarySources, "PrimarySources must not be null");
    this.primarySources = new LinkedHashSet<>(Arrays.asList(primarySources));
    this.webApplicationType = WebApplicationType.deduceFromClasspath();
    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));
    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
    this.mainApplicationClass = deduceMainApplicationClass();
}
----

`WebApplicationType.deduceFromClasspath()` 会根据运行时环境中是否存在应用上下文关联的特定类返回不同的 `WebApplicationType`。以下是 `WebApplicationType.deduceFromClasspath` 的源码：

.WebApplicationType.deduceFromClasspath
[source%nowrap,java]
----
static WebApplicationType deduceFromClasspath() {
    if (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, null) && !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, null)
            && !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, null)) {
        return WebApplicationType.REACTIVE;
    }
    for (String className : SERVLET_INDICATOR_CLASSES) {
        if (!ClassUtils.isPresent(className, null)) {
            return WebApplicationType.NONE;
        }
    }
    return WebApplicationType.SERVLET;
}
----

.总结
|===
|应用类型 |类型说明 |判断条件 |具体子类

|SERVLET
|该应用程序应作为基于 Servlet 的 Web 应用程序运行，并应启动嵌入式 Servlet Web 服务器
|存在 Servlet 和 ConfigurableWebApplicationContext
|AnnotationConfigServletWebServerApplicationContext

|REACTIVE
|该应用程序应作为 reactive Web 应用程序运行，并应启动嵌入式 reactive Web 服务器
|存在 DispatcherHandler 并且不存在 DispatcherServlet 或 ServletContainer
|AnnotationConfigReactiveWebServerApplicationContext

|NONE
|该应用程序不应作为 Web 应用程序运行，也不应启动嵌入式 Web 服务器。
|不是上面两种情况
|AnnotationConfigApplicationContext
|===

为方便表格展示，省去了类的完整路径：

* Servlet：javax.servlet.Servlet
* ConfigurableWebApplicationContext：org.springframework.web.context.ConfigurableWebApplicationContext
* AnnotationConfigServletWebServerApplicationContext：org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext
* DispatcherHandler：org.springframework.web.reactive.DispatcherHandler
* DispatcherServlet：org.springframework.web.servlet.DispatcherServlet
* ServletContainer：org.glassfish.jersey.servlet.ServletContainer
* AnnotationConfigReactiveWebServerApplicationContext：org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext
* AnnotationConfigApplicationContext：org.springframework.context.annotation.AnnotationConfigApplicationContext
